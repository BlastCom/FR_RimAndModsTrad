#include "oldProcces.h"

int oldProccesMain(void)
{
	FILE* readFile;
	FILE* writeFile;

	char option[2] = { '\n' };
	char defName[64];
	char baliseName[256];
	char text[1024];
	char infoFolderName[128] = "[!] This file should be in a folder named '' [!]";
	char tmp[10] = { 0 };
	char credit[] = "\n\nThis file was generated by a program made by Simon Laflamme ( FlammyHazard / BlastCom )";
	char clipboardLineBuffer[DEFNAME_SIZE + BALISENAME_SIZE + TEXT_SIZE];

	char* ptrInfoFolderNameGoes = &infoFolderName[43];
	char* clipboardBuffer = NULL;

	char* clipboardBuffer_start = NULL;
	char* clipboardBuffer_end = NULL;
	char* clipboardTmp = NULL;

	int flushVar;
	int infoFlag = false;
	int counter = 0;
	int errorContainer = 0;
	int rowBlankFlag = false;
	int read_mode = false;

	while (!read_mode)
	{

		printf("Is the report string related to Keyed or DefInjected ?\nEnter [k/K] for Keyed or [d/D] for DefInjected : ");

		//FFLUSH();

		do
		{
			option[0] = getchar();
		} while (option[0] < 0 || option[0] == '\n');
		//scanf("%1c", option);

		if (option[0] < 'a')
		{
			option[0] += LOWERCASE_OFFSET;
		}

		switch (*option)
		{
		case 'k':
			read_mode = 1;
			break;
		case 'd':
			read_mode = 2;
			break;
		default:
			printf("Unknown option, please enter again or close this window to quit.\n\n");
			break;
		}
	}

	fopen_s(&readFile, INPUT_FILE_NAME, "r");
	fopen_s(&writeFile, OUTPUT_FILE_NAME, "w");

	if (readFile == NULL)
	{
		printf("ERROR READ; PROGRAM STOPED\n");
		return 0;
	}

	if (writeFile == NULL)
	{
		printf("ERROR WRITE; PROGRAM STOPED\n");
		return 0;
	}

	while (!feof(readFile))
	{
		rowBlankFlag = false;
		errorContainer = 0;

		/*======= Read function // Get information from input=======*/
		errorContainer = readRepport(readFile, defName, baliseName, text, read_mode);

		if (errorContainer)
		{
			if (errorContainer == ERROR_DEFNAME)
			{
				printf("\nERROR OVERFLOW DEFNAME; PROGRAM STOPED\n");
				fclose(readFile);
				fclose(writeFile);
				system("pause");
				return 0;
			}
			else if (errorContainer == ERROR_BALISENAME)
			{
				printf("\nERROR OVERFLOW BALISENAME; PROGRAM STOPED\n");
				fclose(readFile);
				fclose(writeFile);
				system("pause");
				return 0;
			}
			else if (errorContainer == ERROR_TEXT)
			{
				printf("\nERROR OVERFLOW TEXT; PROGRAM STOPED\n");
				fclose(readFile);
				fclose(writeFile);
				system("pause");
				return 0;
			}
			else if (errorContainer == ERROR_READ_NO_MODE)
			{
				printf("\nERROR READ: NO OR UNKNOWN MODE; PROGRAM STOPED\n");
				fclose(readFile);
				fclose(writeFile);
				system("pause");
				return 0;
			}
			else if (errorContainer == ERROR_ROWBLANK)
			{
				// Non-fatal Error; Program continue.
				rowBlankFlag = true;
			}
		}

		/*======= End of Read function =======*/

		/*======= Write function // Put new information format in output =======*/
		if (!infoFlag)
		{
			memcpy(tmp, ptrInfoFolderNameGoes, strlen(ptrInfoFolderNameGoes));
			memcpy(ptrInfoFolderNameGoes, defName, strlen(defName));

			ptrInfoFolderNameGoes += strlen(defName);
			memcpy(ptrInfoFolderNameGoes, tmp, strlen(tmp) + 1);

			fputs(infoFolderName, writeFile);
			fputs("\n\n", writeFile);

			infoFlag = true;
		}

		if (!rowBlankFlag)
		{
			errorContainer = writeXML(writeFile, defName, baliseName, text);

			if (errorContainer)
			{
				//Future error management for write function
			}

			counter++;
		}

		/*======= End of Write function =======*/
	}

	fputs(credit, writeFile);

	fclose(readFile);
	fclose(writeFile);

	/*================================= To Clipboard function ====================================*/
	/*++ TODO : put in his own function ++*/

	clipboardBuffer = (char*)calloc(counter * (DEFNAME_SIZE + BALISENAME_SIZE + TEXT_SIZE), sizeof(char));

	fopen_s(&readFile, OUTPUT_FILE_NAME, "r");

	if (readFile == NULL)
	{
		printf("ERROR READ AT CLIPBOARD STEP; PROGRAM STOPED\n");
		return 0;
	}

	while (!(feof(readFile)))
	{
		fgets(clipboardLineBuffer, sizeof(clipboardLineBuffer), readFile);
		strcat(clipboardBuffer, clipboardLineBuffer);
	}

	clipboardBuffer_start = strchr(clipboardBuffer, '<');
	clipboardBuffer_end = strrchr(clipboardBuffer, '>');
	clipboardBuffer_end[1] = '\0';

	clipboardTmp = _strdup(clipboardBuffer_start);
	memset(clipboardTmp, '\0', strlen(clipboardTmp));
	clipboardTmp[0] = '\t';

	strcat(clipboardTmp, clipboardBuffer_start);

	toClipboard((const char*)clipboardTmp);

	free(clipboardBuffer);

	/*============================= End of Clipboard function ====================================*/

	printf("Process Done !\n");
	printf("%i xml tags were generated from the input file.\nThe output can be found inside output.xml\n\n", counter);
	printf("Sended to Clipboard !\n\n");

	system("pause");
	return 0;
}

int readRepport(FILE* readFile, char* defName, char* baliseName, char* text, int mode)
{
	char buffer[BUFFER_SIZE];
	char* strBuffer;
	char* ptrLastApostrophe;

	int i;
	int step_val = 0;
	int index;

	memset(buffer, 0, sizeof(buffer));
	memset(defName, 0, sizeof(defName));
	memset(baliseName, 0, sizeof(baliseName));
	memset(text, 0, sizeof(text));

	fgets(buffer, BUFFER_SIZE, readFile);
	strBuffer = buffer;

	switch (mode)
	{
	case 1:
		step_val = 1;
		strcpy(defName, "Keyed");
		break;
	case 2:
		step_val = 0;
		break;
	default:
		return ERROR_READ_NO_MODE;
		break;
	}

	for (i = step_val; i < 2; i++)
	{
		index = 0;
		do
		{
			while (strBuffer[0] == '\t' || strBuffer[0] == ' ' || strBuffer[0] == '\n' || strBuffer[0] == 0)
			{
				strBuffer++;
				if (strBuffer[0] == '\0')
				{
					return ERROR_ROWBLANK;
				}
			}
			if (i == 0)
				defName[index++] = strBuffer[0];	//!
			else if (i == 1)
				baliseName[index++] = strBuffer[0];
			strBuffer++;

			if (i == 0 && index >= DEFNAME_SIZE)
				return ERROR_DEFNAME;
			else if (i == 1 && index >= BALISENAME_SIZE)
				return ERROR_BALISENAME;

		} while (strBuffer[0] != ' ');
		strBuffer++;

		if (i == 0) //!
			defName[--index] = '\0';
		else if (i == 1)
			baliseName[index] = '\0';
	}

	strBuffer++;
	index = 0;
	ptrLastApostrophe = strrchr(strBuffer, APOSTROPHE_ASCII);
	do
	{
		text[index++] = strBuffer[0];
		strBuffer++;
		if (index >= TEXT_SIZE)
			return ERROR_TEXT;

	} while (ptrLastApostrophe != strBuffer);
	text[index] = '\0';

	return SUCCES;
}

int writeXML(FILE* writeFile, char* defName, char* baliseName, char* text)
{
	char bufferWrite[BUFFER_SIZE];

	int index;

	memset(bufferWrite, 0, sizeof(bufferWrite));

	index = 0;
	bufferWrite[index++] = '\t';
	bufferWrite[index++] = '<';
	strcat(bufferWrite, baliseName);
	index += strlen(baliseName);
	bufferWrite[index++] = '>';
	strcat(bufferWrite, text);
	index += strlen(text);
	bufferWrite[index++] = '<';
	bufferWrite[index++] = '/';
	strcat(bufferWrite, baliseName);
	index += strlen(baliseName);
	bufferWrite[index++] = '>';
	bufferWrite[index++] = '\n';

	fputs(bufferWrite, writeFile);

	return 0;
}
